package guiDelegate;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.event.MouseWheelEvent;
import java.awt.event.MouseWheelListener;
import java.awt.image.BufferedImage;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;
import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JRadioButton;
import javax.swing.JTextField;
import javax.swing.JToolBar;
import javax.swing.filechooser.FileNameExtensionFilter;

import model.Canvas;
import model.MandelbrotCalculator;
import model.MandelbrotModel;

/**
 * The GuiDelegate class contains the method to establish the GUI and user
 * interaction.
 * 
 * @author ZHAOHUI XU
 *
 */
public class GuiDelegate extends JComponent {
	private static final long serialVersionUID = 1L;
	public final static int width = 850;
	public final static int height = 850;
	public static final int menuWidth = 120;
	public static final int wheelZoomInRatio = 100;
	private BufferedImage image;
	private JFrame frame;
	private JMenu file;
	private JMenuBar menu = new JMenuBar();
	private JMenuItem save;
	private JMenuItem saveImage;
	private JMenuItem load;
	private JToolBar toolbar;
	private JButton changeColor;
	private JButton reset;
	private JButton redo;
	private JButton undo;
	private boolean allowChange = false;
	private boolean panSelected = false;
	private JRadioButton pan;
	private JRadioButton magnification;
	private JLabel maxIteration;
	private JTextField textfield;
	private JButton applyChange;
	private boolean released = false;
	private boolean releasedAgain = false;
	private boolean zoomMagnification = false;
	private int beginPoint[] = new int[2];
	private int endPoint[] = new int[2];
	private int[] mouseLocation = new int[2];
	private double x1;
	private double y1;
	private double x2;
	private double y2;
	private double xMin;
	private double yMin;
	private double xMax;
	private double yMax;
	private double side;
	private static final double INITIAL_MIN_REAL = -2.0;
	private ArrayList<int[]> mousePoint = new ArrayList<int[]>();

	Canvas canvas;
	MandelbrotModel mandelbrotModel;
	MandelbrotCalculator mandelCalc;

	/**
	 * Constructor. set size of the image, setup all components.
	 */
	public GuiDelegate() {
		image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);// set color style of the framework.
		frame = new JFrame("GUI Delegate"); // set title of the framework.
		mandelbrotModel = new MandelbrotModel(width, height);// transport relevant data to the model file.
		setup();
	}

	@Override
	/**
	 * Set the size of the frame if not we cannot see the image.
	 */
	public void addNotify() {
		setPreferredSize(new Dimension(width, height));
	}

	@Override
	/**
	 * Override paint method. Paint the image generated from the Model part and the
	 * square used to indicate the part to zoom in or the line used to indicate the
	 * part to pan move.
	 * 
	 * @param graphics
	 */
	public void paint(Graphics graphics) {

		mandelbrotModel.updateImage();
		image = mandelbrotModel.getImage();
		Graphics2D graphics2D = (Graphics2D) graphics;
		graphics2D.drawImage(image, 0, 0, null);
		// Painting the area generated by the location where mouse clicked (x1, y1) and
		// dragged to (x2, y2).
		if (!released) {
			if (!mousePoint.isEmpty()) {
				int x1 = mousePoint.get(0)[0];
				int x2 = mousePoint.get(mousePoint.size() - 1)[0];
				int y1 = mousePoint.get(0)[1] - menuWidth;
				int y2 = mousePoint.get(mousePoint.size() - 1)[1] - menuWidth;
				square(x1, x2, y1, y2);
				graphics2D.drawRect((int) this.getxMin(), (int) this.getyMin(), (int) this.getSide(),
						(int) this.getSide());

			}

			if (zoomMagnification) {
				graphics.setColor(Color.blue);
				graphics.drawString("Zoom Magnification: " + Math.abs(this.INITIAL_MIN_REAL
						/ mandelbrotModel.getData().get(mandelbrotModel.getStateIndex()).getMinReal()), 0, 12);

			} else {
				graphics.drawString("", 0, 12);
			}
		} else if (!releasedAgain) {
			if (!mousePoint.isEmpty()) {
				int x1 = mousePoint.get(0)[0];
				int x2 = mousePoint.get(mousePoint.size() - 1)[0];
				int y1 = mousePoint.get(0)[1] - menuWidth;
				int y2 = mousePoint.get(mousePoint.size() - 1)[1] - menuWidth;
				line(x1, x2, y1, y2);
				graphics2D.drawLine(x1, y1, x2, y2);
			}
			if (zoomMagnification) {
				graphics.setColor(Color.blue);
				graphics.drawString("Zoom Magnification: " + Math.abs(this.INITIAL_MIN_REAL
						/ mandelbrotModel.getData().get(mandelbrotModel.getStateIndex()).getMinReal()), 0, 12);

			} else {
				graphics.drawString("", 0, 12);
			}
		}

	}

	/**
	 * Setup all components of the main frame including the menu set,the tool
	 * bar,mouse listeners,and the main canvas of Mandelbrot Set.
	 * 
	 */
	private void setup() {
		setMenu();
		setToolbar();
		addMouseListeners();
		Container contentPane = frame.getContentPane();// Create a container to add components to the framework.
		contentPane.add(toolbar, BorderLayout.NORTH);// add the tool bar at the north part of the framework.
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);// if user click the exit button the framework will close.
		frame.setResizable(true);// true is the window size can be changed.
		contentPane.add(this);// add the above information to the framework.
		frame.pack();// Let the frame automatically adjust its size according to the size of the
						// component.
		frame.setVisible(true);// The data model has been constructed to allow the JVM to execute the paint
								// method based on the data model to start drawing and display it on the screen.
	}

	/**
	 * Setup the menu set with the file pull-down menu which includes save data,
	 * save image, load saved data.
	 */
	private void setMenu() {
		file = new JMenu("File");
		// set the menu item which allows user to save the current SER file.
		save = new JMenuItem("Save Data");
		save.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				try {
					mandelbrotModel.saveParamFile();
				} catch (IOException e2) {
					e2.getMessage();
				}
			}
		});

		// set the menu item which allows user to save the image in JPG style.
		saveImage = new JMenuItem("Save Image");
		saveImage.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				try {
					mandelbrotModel.saveImage();
				} catch (IOException e1) {
					e1.getMessage();
				}

			}
		});

		// set the menu item which allows user to load the local SER file
		load = new JMenuItem("Load Local Data");
		load.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				// A file fileChooser is implemented to choose the data to load from local file.
				JFileChooser fileChooser = new JFileChooser();
				FileNameExtensionFilter filter = new FileNameExtensionFilter("SER files", "ser");
				fileChooser.setFileFilter(filter);
				int returnVal = fileChooser.showOpenDialog(null);
				if (returnVal == JFileChooser.APPROVE_OPTION) {
					try {
						// invoke the loading method to update the model.
						mandelbrotModel.loadParamFile(fileChooser.getSelectedFile());
						frame.repaint();
					} catch (FileNotFoundException e1) {
						e1.getMessage();
					} catch (IOException e1) {
						e1.getMessage();
					} catch (ClassNotFoundException e1) {
						e1.getMessage();
					}
				}
			}
		});
		/**
		 * Add all menu set to the frame.
		 */
		file.add(save);
		file.add(saveImage);
		file.add(load);
		menu.add(file);
		frame.setJMenuBar(menu);
	}

	/**
	 * Setup the frame with all buttons including change color, reset, undo, redo,
	 * pan select button, show current max iteration, text field to change max
	 * iteration, and button to update with the given max iteration.
	 */
	private void setToolbar() {
		toolbar = new JToolBar();
		// set the tool bar button which allows user to change the image color.
		changeColor = new JButton("Change Colour");
		changeColor.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				if (allowChange) {
					mandelbrotModel.removeData();
					allowChange = false;
				}
				mandelbrotModel.setNextState();
				frame.repaint();
			}
		});
		// set the tool bar button which allows user to reset the view and setting.
		reset = new JButton("Reset");
		reset.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				mandelbrotModel = new MandelbrotModel(width, height);
				textfield
						.setText("" + mandelbrotModel.getData().get(mandelbrotModel.getStateIndex()).getMaxIteration());
				frame.repaint();
			}
		});

		// set the tool bar button which allows user to back to the last view and
		// setting.
		undo = new JButton("Undo");
		undo.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				if (mandelbrotModel.getStateIndex() > 0) {
					mandelbrotModel.setStateIndex(mandelbrotModel.getStateIndex() - 1);
					frame.repaint();
					textfield.setText(
							"" + mandelbrotModel.getData().get(mandelbrotModel.getStateIndex()).getMaxIteration());
				}
				allowChange = true;
			}
		});

		// set the tool bar button which allows user to go to the next view and setting.
		redo = new JButton("Redo");
		redo.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				if (allowChange && mandelbrotModel.getStateIndex() < mandelbrotModel.getData().size() - 1) {
					mandelbrotModel.setStateIndex(mandelbrotModel.getStateIndex() + 1);
					textfield.setText(
							"" + mandelbrotModel.getData().get(mandelbrotModel.getStateIndex()).getMaxIteration());
					frame.repaint();
				}
			}
		});

		// set the tool bar radio button which allows user to select a distance and
		// direction on the image.
		pan = new JRadioButton("Pan Permission");
		pan.addActionListener(new ActionListener() { // to translate event for this button into appropriate model method call.
														
			public void actionPerformed(ActionEvent e) {
				// should call method in model class if you want it to affect model
				if (pan.isSelected()) {
					panSelected = true;
					JOptionPane.showMessageDialog(frame, "Now you can move the image!");
				} else {
					panSelected = false;
					JOptionPane.showMessageDialog(frame, "Now you can zoom the image!");

				}
			}
		});

		magnification = new JRadioButton("Show Magnification");
		magnification.addActionListener(new ActionListener() { // to translate event for this button into appropriate model method call.
			public void actionPerformed(ActionEvent e) {
				if (magnification.isSelected()) {
					zoomMagnification = true;
					frame.repaint();
				} else {
					zoomMagnification = false;
					frame.repaint();
				}
			}
		});

		// set the tool bar button which allows user to show current max iteration and
		// apply change max iteration value with hitting the enter key.
		maxIteration = new JLabel("Current max iteration: ");
		textfield = new JTextField(
				"" + mandelbrotModel.getData().get(mandelbrotModel.getStateIndex()).getMaxIteration());
		textfield.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				String text = textfield.getText();
				int maxIteration = Integer.parseInt(text);
				if (allowChange) {
					mandelbrotModel.removeData();
					allowChange = false;
				}
				mandelbrotModel.setNextState(maxIteration);
				frame.repaint();
			}
		});

		// set the tool bar button which allows user to add a new state with given
		// maxIteration and former settings.
		applyChange = new JButton("Change");
		applyChange.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				String text = textfield.getText();
				int maxIteration = Integer.parseInt(text);
				if (allowChange) {
					mandelbrotModel.removeData();
					allowChange = false;
				}
				mandelbrotModel.setNextState(maxIteration);
				frame.repaint();
			}
		});

		/**
		 * Add all tool bar set to the frame.
		 */
		toolbar.add(changeColor);
		toolbar.addSeparator();
		toolbar.add(reset);
		toolbar.addSeparator();
		toolbar.add(undo);
		toolbar.addSeparator();
		toolbar.add(redo);
		toolbar.addSeparator();
		toolbar.add(pan);
		toolbar.addSeparator();
		toolbar.add(magnification);
		toolbar.addSeparator();
		toolbar.add(maxIteration);
		toolbar.add(textfield);
		toolbar.addSeparator();
		toolbar.add(applyChange);
	}

	/**
	 * Add the mouse listeners so that the system can monitor mouse events which
	 * includes mouse pressed, mouse released, mouse dragged, mouse moved, mouse
	 * wheel moved. and override the original method that we do not need to use.
	 */
	private void addMouseListeners() {
		frame.addMouseListener(new MouseListener() {
			@Override
			public void mouseClicked(MouseEvent e) {
			}

			@Override
			/**
			 * give the coordinates of the first point when clicked.
			 * 
			 * @param e
			 */
			public void mousePressed(MouseEvent e) {
				if (!panSelected) {
					released = false;
					beginPoint = new int[] { e.getX(), e.getY() };
				} else {
					releasedAgain = false;
					beginPoint = new int[] { e.getX(), e.getY() };
				}
			}

			@Override
			/**
			 * if mouse is released, generate new Mandelbrot Set.
			 */
			public void mouseReleased(MouseEvent e) {
				if (!panSelected) {
					endPoint = new int[] { e.getX(), e.getY() };
					double x1 = beginPoint[1] - menuWidth;
					double x2 = endPoint[1] - menuWidth;
					double y1 = beginPoint[0];
					double y2 = endPoint[0];
					zoom(x1, x2, y1, y2);
				} else {
					endPoint = new int[] { e.getX(), e.getY() };
					double x1 = beginPoint[1] - menuWidth;
					double x2 = endPoint[1] - menuWidth;
					double y1 = beginPoint[0];
					double y2 = endPoint[0];
					panMove(x1, x2, y1, y2);
				}
			}

			@Override
			public void mouseEntered(MouseEvent e) {
			}

			@Override
			public void mouseExited(MouseEvent e) {
			}
		});

		frame.addMouseMotionListener(new MouseMotionListener() {

			/**
			 * if mouse is dragged, record the coordinate of mouse point.
			 * 
			 * @param e
			 */
			public void mouseDragged(MouseEvent e) {
				if (!panSelected) {
					mousePoint.add(new int[] { e.getX(), e.getY() });
					frame.repaint();
				} else {
					mousePoint.add(new int[] { e.getX(), e.getY() });
					frame.repaint();
				}
			}

			/**
			 * if mouse is moved, record the new coordinate of mouse point.
			 * 
			 * @param e
			 */
			public void mouseMoved(MouseEvent e) {
				if (!panSelected) {
					mouseLocation = new int[] { e.getX(), e.getY() };
				} else {
					mouseLocation = new int[] { e.getX(), e.getY() };
				}
			}
		});

		frame.addMouseWheelListener(new MouseWheelListener() {
			/**
			 * if mouse wheels is used, the screen will zoom in specified ratio(only in the
			 * case of zoom not pan).
			 * 
			 * @param e
			 */
			@Override
			public void mouseWheelMoved(MouseWheelEvent e) {
				if (!panSelected) {
					int notches = e.getWheelRotation();
					if (notches < 0) {
						double x1 = 0 + (mouseLocation[1] - 0) / wheelZoomInRatio;
						double y1 = 0 + (mouseLocation[0] - 0) / wheelZoomInRatio;
						double x2 = width - (width - mouseLocation[1]) / wheelZoomInRatio;
						double y2 = height - (height - mouseLocation[0]) / wheelZoomInRatio;
						zoom(x1, x2, y1, y2);
					} else {
						double x1 = 0 - (mouseLocation[1] - 0) / wheelZoomInRatio;
						double y1 = 0 - (mouseLocation[0] - 0) / wheelZoomInRatio;
						double x2 = width + (width - mouseLocation[1]) / wheelZoomInRatio;
						double y2 = height + (height - mouseLocation[0]) / wheelZoomInRatio;
						zoom(x1, x2, y1, y2);
					}
				}
			}
		});

	}

	/**
	 * The method implemented to zoom in with given square.
	 * 
	 * @param x1
	 *            x-coordinate of the first point.
	 * @param x2
	 *            x-coordinate of the second point.
	 * @param y1
	 *            y-coordinate of the first point.
	 * @param y2
	 *            y-coordinate of the second point.
	 */
	private void zoom(double x1, double x2, double y1, double y2) {
		square(x1, x2, y1, y2);
		if (allowChange) {
			mandelbrotModel.removeData();
			allowChange = false;
		}
		// generate a new state of Mandelbrot set with the square to zoom in.
		if (x1 != x2 || y1 != y2) {
			mandelbrotModel.setNextState(this.getxMin(), this.getxMax(), this.getyMin(), this.getyMax());// pass the
																											// specified
																											// data to
																											// model to
																											// handle
			frame.repaint();
			try {
				Thread.sleep(40);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			mousePoint = new ArrayList<int[]>();
		}
		released = true;
	}

	/**
	 * The method implemented to move graph with line.
	 * 
	 * @param x1
	 *            x-coordinate of the first point.
	 * @param x2
	 *            x-coordinate of the second point.
	 * @param y1
	 *            y-coordinate of the first point.
	 * @param y2
	 *            y-coordinate of the second point.
	 */
	private void panMove(double x1, double x2, double y1, double y2) {
		this.x1 = x1;
		this.x2 = x2;
		this.y1 = y1;
		this.y2 = y2;

		line(x1, x2, y1, y2);
		if (allowChange) {
			mandelbrotModel.removeData();
			allowChange = false;
		}
		// generate a new state of Mandelbrot set with the line to move graph.
		if (x1 != x2 || y1 != y2) {
			mandelbrotModel.setNextState2(this.x1, this.x2, this.y1, this.y2);// pass the coordinate data to model to
																				// handle
			frame.repaint();
			try {
				Thread.sleep(40);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			mousePoint = new ArrayList<int[]>();
		}
		released = true;
	}

	/**
	 * There exist five attributes as the four boundaries of a square and the
	 * square's side length. The constructor below takes in two pairs of Cartesian
	 * coordinates and calculate the four attributes.
	 * 
	 * @return
	 */
	public double getxMin() {
		return xMin;
	}

	/**
	 * @return
	 *
	 */
	public double getyMin() {
		return yMin;
	}

	/**
	 * @return
	 *
	 */
	public double getxMax() {
		return xMax;
	}

	/**
	 * @return
	 *
	 */
	public double getyMax() {
		return yMax;
	}

	/**
	 * @return
	 *
	 */
	public double getSide() {
		return side;
	}

	/**
	 * This method generates a square that starts at the first point, points to the
	 * second point's direction and has the side length of the longer projection.
	 * 
	 * @param x1
	 *            x-coordinate of the first point.
	 * @param x2
	 *            x-coordinate of the second point.
	 * @param y1
	 *            y-coordinate of the first point.
	 * @param y2
	 *            y-coordinate of the second point.
	 */
	public void square(double x1, double x2, double y1, double y2) {
		side = Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2));
		if (x1 < x2 && y1 < y2) {
			xMin = x1;
			yMin = y1;
			xMax = x1 + side;
			yMax = y1 + side;
		} else {
			if (x1 < x2 && y1 >= y2) {
				xMin = x1;
				yMax = y1;
				xMax = x1 + side;
				yMin = y1 - side;
			} else {
				if (x1 >= x2 && y1 < y2) {
					xMax = x1;
					yMin = y1;
					xMin = x1 - side;
					yMax = y1 + side;
				} else {
					if (x1 >= x2 && y1 >= y2) {
						xMax = x1;
						yMax = y1;
						xMin = x1 - side;
						yMin = y1 - side;
					}
				}
			}
		}
	}

	/**
	 * This method generates a line that starts at the first point, points to the
	 * second point's direction and has the side length of the longer projection.
	 * 
	 * @param x1
	 *            x-coordinate of the first point.
	 * @param x2
	 *            x-coordinate of the second point.
	 * @param y1
	 *            y-coordinate of the first point.
	 * @param y2
	 *            y-coordinate of the second point.
	 */
	public void line(double x1, double x2, double y1, double y2) {
		side = Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2));
		if (x1 < x2 && y1 < y2) {
			xMin = x1;
			yMin = y1;
			xMax = x1 + side;
			yMax = y1 + side;
		} else {
			if (x1 < x2 && y1 >= y2) {
				xMin = x1;
				yMax = y1;
				xMax = x1 + side;
				yMin = y1 - side;
			} else {
				if (x1 >= x2 && y1 < y2) {
					xMax = x1;
					yMin = y1;
					xMin = x1 - side;
					yMax = y1 + side;
				} else {
					if (x1 >= x2 && y1 >= y2) {
						xMax = x1;
						yMax = y1;
						xMin = x1 - side;
						yMin = y1 - side;
					}
				}
			}
		}
	}

}
